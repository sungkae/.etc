# Huffman Coding  
http://guides.github.com/features.mastering-markdown/ 
Huffman Coding은 무손실실 압축에 쓰이는 엔트로피 부호화의 일종으로, 데이터 문자의 등장 빈도에 따라서 다른 길이의 부호를 사용하는 알고리즘이다. 1952년 

당시 박사과정 학생이던 데이비드 허프만이 <<A Method for the Construction of Minimum-Redundancy Codes>>란 제목으로 처음 논문을 발표했다.  

Huffman Coding은 문자들의 빈도로부터 **접두 부호**(어떤 한 문자에 대한 부호가 다른 부호들의 접두어가 되지 않는 부호)를 만들어 내는 알고리즘으로, 적게 나오는 문자일수록 더 긴 부호를 쓰고 많이 나올수록 더 짧은 부호를 쓴다.  
Huffman Coding은 주어진 빈도에 대해서 항상 최적의 접두 부호를 만들어 내며, 이 과정은 빈도가 정렬되어 있을 경우 O(n)만에 가능하다. 각 문자들의 빈도가 2의 거듭제곱 꼴이거나 모두 같을 경우 이 접두 부호는 간단한 이진 블록 부호와 동일하다.
  
## 알고리즘
1. 초기화: 모든 기호를 출현 빈도수에 따라 나열한다.
2. 단 한 가지 기호가 남을 때까지 아래 단계를 반복한다.
	1. 목록으로부터 가장 빈도가 낮은 것을 2개 고른다.
	2. 그 다음 허프만이 두가지 기호를 부모 노드를 가지는 부트리를 구성하고 자식노들을 생성한다.
	부모 노드 단 기호들의 빈도수를 더하여 주 노드에 할당하고 목록의 순서에 맞도록 목록에 삽입한다.
	3. 목록에서 부모노드에 포함된 기호를 제거한다.
  
허프만 알고리즘은 입력 기호를 리프 노드로하는 이진 트리를 만들어서 접두 부호를 만들어 내는 알고리즘이다.  
  
### Example
1. CDDCACBCBCCCBBCDA (17Bytes = 136bits)  
	1. 각 문자열별로 빈도수를 검사한다.  
	2A 4B 8C 3D  
	2. 빈도수 순서대로 정렬한다.  
	8C 4B 3D 2A  
	3. 가장 낮은 두 그룹을 묶어서 하나의 그룹으로 만든다.  
	8C 4B 5[3D, 2A]  
	  
	2. 빈도수 순서대로 정렬한다.  
	8C 55[3D, 2A] 4B  	
	3. 가장 낮은 두 그룹을 묶어서 하나의 그룹으로 만든다.  
	8C 9[5[3D, 2A], 4B]  
	  
	2. 빈도수 순서대로 정렬한다.
	9[5[3D, 2A], 4B] 8C  
	3. 가장 낮은 두 그룹을 묶어서 하나의 그룹으로 만든다.  
	17[9[5[3D, 2A], 4B], 8C]  
2. 트리 완성  
가장 윗 트리에서부터 빈도 수가 큰 트리에 0을 작은 트리에 1을 부여한다.  
17[9(0)[5(0)[3(0)D, 2(1)A], 4(1)B], 8(1)C]  
3. 위 트리를 기준으로 각 문자열의 비트를 참조한다.  
부모노드에서 출발하여 문자열에 다다를때까지 비트를 더하여 참조한다. A = 001, D = 000 이 된다.  
초기 문자열을 할당된 비트로 치환하면  
**1000000100110110111101011000001**  가 된다.  
17byte이 31 bits = 8 bytes가 되었다.
